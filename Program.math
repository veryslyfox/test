var cursor = 0;
var code = "";
var file = File.OpenText("Program.math");
while (true)
{
    code = file.ReadLine();
    if (code == null)
    {
        break;
    }
    if (code.Contains('='))
    {
        Variable.Construct(code);
    }
    var left = Left('(');
    Right(')');
    var right = Right(')');
}
Console.ReadKey();
string? Left(char c)
{
    var result = "";
    while (code[cursor] != c && cursor != 0)
    {
        cursor--;
        result += code[cursor];
    }
    if (cursor == 0)
    {
        return null;
    }
    else
    {
        return result;
    }
}
string? Right(char c)
{
    var result = "";
    while (code[cursor] != c && cursor != code.Length - 1)
    {
        cursor++;
        result += code[cursor];
    }
    if (cursor == code.Length - 1)
    {
        return null;
    }
    else
    {
        return result;
    }
}
string Span(string input, string span)
{
    if (input.Substring(0, span.Length) == span)
    {
        return input.Substring(span.Length);
    }
    else
    {
        return input;
    }
}
class Variable
{
    public Variable(double value, string name)
    {
        Value = value;
        Name = name;
        Variables.Add(name, value);
    }

    public double Value { get; }
    public string Name { get; }
    public static Dictionary<string, double> Variables = new Dictionary<string, double>();

    public static void Construct(string constructor)
    {
        var value = "";
        var name = "";
        var isValue = false;
        foreach (var item in constructor)
        {
            if (item == '=')
            {
                isValue = true;
                continue;
            }
            if (isValue)
            {
                value += item;
            }
            else
            {
                name += item;
            }
        }
        if (double.TryParse(value, out double i))
        {
            new Variable(i, name);
        }
        else
        {
            Console.WriteLine("Ошибка ввода числа");
            new Variable(0, "");
        }
    }
}
int[] MergeSort(int[] array)
{
    if (array.Length <= 1)
    {
        return array;
    }
    return Merge(MergeSort(array[..(array.Length / 2)]), MergeSort(array[(array.Length / 2)..]));
}
int[] Merge(int[] left, int[] right)
{
    var result = new int[left.Length + right.Length];
    var p = 0;
    var q = 0;
    var last = 0;
    for (int i = 0; i < result.Length; i++)
    {
        last = result[p + q];
        var isContinue = false;
        if (last > p && q != right.Length - 1)
        {
            p++;
            isContinue = true;
        }
        if (last > q && p != right.Length - 1)
        {
            q++;
            isContinue = true;
        }
        if (isContinue)
        {
            continue;
        }
        if (left[p] < right[q])
        {
            result[i] = left[p];
        }
        else
        {
            result[i] = right[q];
        }
    }
    return result;
}
var array = new int[] { 3, 2, 1 };
foreach (var item in MergeSort(array))
{
    Console.WriteLine(item);
}
Console.ReadKey();
using System.Collections;

int[] ToFactorialSystem(long value)
{
    long factorial = 1;
    var af = 1;
    for (long i = 1, result = 1; result * (i + 1) < value; i++, result *= i, factorial = result, af++) ;
    var resultArray = new int[af];
    var count = 0;
    while (value != 0)
    {
        if (factorial == 0)
        {
            break;
        }
        resultArray[count] = (int)(value / factorial);
        value = value % factorial;
        if (af - count == 0)
        {
            break;
        }
        factorial /= (af - count);
        count++;
    }
    return resultArray;
}
long HashConverter(long value)
{
    BigInteger integer = new BigInteger();
    foreach (var item in ToFactorialSystem(value))
    {
        integer = (integer << 7) ^ item;
    }
    return (long)(integer & long.MaxValue) ^ 4294967296;
}
long HashConverterI(long value, int iteff)
{
    if (iteff == 0)
    {
        return value;
    }
    return HashConverter(HashConverterI(value, iteff - 1));
}
long Hash(string fileName)
{
    if (fileName == null)
    {
        return 0;
    }
    if (!File.Exists(fileName))
    {
        return 0;
    }
    var hash = 0L;
    var file = File.Open(fileName, FileMode.Open);
    var array = new byte[8];
    var cursor = 0;
    while (cursor >= file.Length)
    {
        cursor++;
        file.Read(array);
        hash = HashConverter(hash ^ (long)(new BigInteger(array)));
    }
    return hash;
}
while (true)
{
    Console.WriteLine(Hash(Console.ReadLine()));
}
// Console.WriteLine(Right("2/234/56", "0123456", 5));
// Console.ReadKey();
// int[] ToFactorialSystem(long value)
// {
//     long factorial = 1;
//     var af = 1;
//     for (long i = 1, result = 1; result * (i + 1) < value; i++, result *= i, factorial = result, af++) ;
//     var resultArray = new int[af];
//     var count = 0;
//     while (value != 0)
//     {
//         if (factorial == 0)
//         {
//             break;
//         }
//         resultArray[count] = (int)(value / factorial);
//         value = value % factorial;
//         if (af - count == 0)
//         {
//             break;
//         }
//         factorial /= (af - count);
//         count++;
//     }
//     return resultArray;
// }
// long HashConverter(long value)
// {
//     BigInteger integer = new BigInteger();
//     foreach (var item in ToFactorialSystem(value))
//     {
//         integer = (integer << 2) ^ item;
//     }
//     return (long)(integer & long.MaxValue) ^ 4294967296;
// }
// double GetValue(string e)
// {
//     var bracket = false;
//     var insert = 0;
//     var inBracket = "";
//     foreach (var item in e)
//     {
//         if (item == '(')
//         {
//             bracket = true;
//             continue;
//         }
//         if (bracket)
//         {
//             if (item == ')')
//             {
//                 bracket = false;
//                 e = e.Replace(inBracket, GetValue(inBracket).ToString());
//                 continue;
//             }
//             inBracket += item;
//         }
//         else
//         {
//             insert++;
//         }
//     }
//     return GetValueBracketless(e);
// }
// double GetValueBracketless(string e)
// {
//     for (int i = 0; i < e.Length; i++)
//     {
//         if (e[i] == '*')
//         {
//             if (double.TryParse(Left(e, "0123456789.", i), out double left) && double.TryParse(Right(e, "0123456789.", i), out double right))
//             {
//                 e = e.Remove(i, )
//                 e = e.Insert(i, (left * right).ToString());
//             }
//             else
//             {
//                 Console.WriteLine("Error");
//             }
//         }
//         if (e[i] == '/')
//         {
//             if (double.TryParse(Left(e, "0123456789.", i), out double left) && double.TryParse(Right(e, "0123456789.", i), out double right))
//             {
//                 e = e.Insert(i, (left / right).ToString());
//             }
//             else
//             {
//                 Console.WriteLine("Error");
//             }
//         }
//     }
//     for (int i = 0; i < e.Length; i++)
//     {
//         if (e[i] == '+')
//         {
//             if (double.TryParse(Left(e, "0123456789.", i), out double left) && double.TryParse(Right(e, "0123456789.", i), out double right))
//             {
//                 e = e.Insert(i, (left + right).ToString());
//             }
//             else
//             {
//                 Console.WriteLine("Error");
//             }
//         }
//         if (e[i] == '/')
//         {
//             if (double.TryParse(Left(e, "0123456789.", i), out double left) && double.TryParse(Right(e, "0123456789.", i), out double right))
//             {
//                 e = e.Insert(i, (left - right).ToString());
//             }
//             else
//             {
//                 Console.WriteLine("Error");
//             }
//         }
//     }
// }
// string Left(string e, string values, int index) // Идти влево и читать e с index, пока символы входят в строку values
// {
//     var beginIndex = index;
//     var result = "";
//     index--;
//     while (index == -1 && values.Contains(e[index]))
//     {
//         result = e[index] + result;
//         index--;
//     }
//     return result;
// }
// string Right(string e, string values, int index) // Идти влево и читать e с index, пока символы входят в строку values
// {
//     var beginIndex = index;
//     var result = "";
//     index++;
//     while (index != e.Length && values.Contains(e[index]))
//     {
//         result = result + e[index];
//         index++;
//     }
//     return result;
// }
using System.Media;
try
{
    var textFrequency = new Dictionary<(char, char, char, char), int>();
    var file = File.Open("Text", FileMode.Open);
    StreamReader writer = new(file);
    char a = 'p';
    char b = 'i';
    char c = 'k';
    char d = 'u';
    var line = "";
    while (true)
    {
        line = writer.ReadLine();
        if (line == null)
        {
            break;
        }
        var clearedLine = "";
        for (int i = 0; i < line.Length; i++)
        {
            if ((int)line[i] is > 31 and < 128)
            {
                clearedLine += line[i];
            }
        }
        line = clearedLine;
        foreach (var item in line)
        {
            c = d;
            b = c;
            a = b;
            d = item;
            if (!textFrequency.ContainsKey((a, b, c, d)))
            {
                textFrequency.Add((a, b, c, d), 1);
            }
            textFrequency[(a, b, c, d)] += 1;
        }
    }
    var count = 0;
    var top = new Dictionary<(char, char, char), char>();
    for (int x = 32; x < 128; x++)
    {
        for (int y = 32; y < 128; y++)
        {
            for (int z = 32; z < 128; z++)
            {
                var maxIndex = 0;
                var max = -1;
                for (int w = 32; w < 128; w++)
                {
                    var freq = textFrequency.ContainsKey(((char)x, (char)y, (char)z, (char)w)) ? textFrequency[((char)x, (char)y, (char)z, (char)w)] : 0;
                    if (max < freq)
                    {
                        maxIndex = w;
                        max = freq;
                        break;
                    }
                }
                top.Add(((char)x, (char)y, (char)z), (char)maxIndex);
                count++;
            }
        }
    }
    var text = new char[100];
    text[0] = 'D';
    text[1] = 'o';
    text[2] = 'n';
    for (int i = 3; i < 100; i++)
    {
        text[i] = top[(text[i - 1], text[i - 2], text[i - 3])];
    }
    Console.WriteLine(new string(text));
}
catch (Exception exception)
{
    Console.WriteLine(exception);
}
finally
{
    Console.ReadKey();
}
// try
// {
//     Console.WriteLine(Computing("2 * 3"));
//     double Computing(string e)
//     {
//         var tokens = Tokenize(e);
//         return ComputingTokens(tokens.Item1, tokens.Item2);
//     }
//     double ComputingTokens(List<double> numbers, List<Operation> operations)
//     {
//         var count = operations.Count;
//         for (int i = 0; i < count; i++)
//         {
//             if (operations[0] == Operation.Multiply)
//             {
//                 numbers.Insert(i, numbers[i] * numbers[i + 1]);
//                 numbers.RemoveAt(i + 1);
//                 numbers.RemoveAt(i + 1);
//                 operations.RemoveAt(0);
//             }
//             if (operations[0] == Operation.Division)
//             {
//                 numbers.Insert(i, numbers[i] / numbers[i + 1]);
//                 numbers.RemoveAt(i + 1);
//                 numbers.RemoveAt(i + 1);
//                 operations.RemoveAt(0);
//             }
//         }
//         for (int i = 0; i < count; i++)
//         {
//             if (operations[i] == Operation.Addition)
//             {
//                 numbers.Insert(i, numbers[i] + numbers[i + 1]);
//                 numbers.RemoveAt(i + 1);
//                 numbers.RemoveAt(i + 1);
//                 operations.RemoveAt(0);
//             }
//             if (operations[i] == Operation.Subtraction)
//             {
//                 numbers.Insert(i, numbers[i] - numbers[i + 1]);
//                 numbers.RemoveAt(i + 1);
//                 numbers.RemoveAt(i + 1);
//                 operations.RemoveAt(0);
//             }
//         }
//         return numbers[0];
//     }
//     (List<double>, List<Operation>) Tokenize(string e)
//     {
//         e = e.Replace(" ", "");
//         e += '+';
//         List<double> numbers = new();
//         List<Operation> operations = new();
//         var numberString = "";
//         var bracket = false;
//         var inBracket = "";
//         foreach (var item in e)
//         {
//             var itemCode = (int)item;
//             if (bracket)
//             {
//                 inBracket += item;
//             }
//             if (itemCode is > 47 and < 58 || itemCode == 46)
//             {
//                 if (!bracket)
//                 {
//                     numberString += item;
//                 }
//             }
//             else
//             {
//                 if (item == '(')
//                 {
//                     bracket = true;
//                 }
//                 if (item == ')')
//                 {
//                     var tokens = Tokenize(inBracket);
//                     numbers.Add(ComputingTokens(tokens.Item1, tokens.Item2));
//                     bracket = false;
//                 }
//                 if (item == '+')
//                 {
//                     operations.Add(Operation.Addition);
//                 }
//                 if (item == '-')
//                 {
//                     operations.Add(Operation.Subtraction);
//                 }
//                 if (item == '*')
//                 {
//                     operations.Add(Operation.Multiply);
//                 }
//                 if (item == '/')
//                 {
//                     operations.Add(Operation.Division);
//                 }
//                 if (double.TryParse(numberString, out double number))
//                 {
//                     numbers.Add(number);
//                 }
//                 else
//                 {
//                     Console.WriteLine("Error");
//                     Console.ReadKey();
//                     return new();
//                 }
//                 numberString = "";
//             }
//         }
//         operations.RemoveAt(operations.Count - 1);
//         return (numbers, operations);
//     }


//     // NeuralNetwork network = NeuralNetwork.GetRandomNetwork(0, 1, "64, 64, 32, 32", 0.1, 1);
//     // for (int i = 0; i < 1; i++)
//     // {
//     //     network.CorrectAll(Error);
//     // }
//     // var input = new double[64];
//     // for (int k = 0; k < 32; k++)
//     // {
//     //     var i = 105;
//     //     var j = 2;
//     //     input[k] = i & 1;
//     //     input[k + 32] = j & 1;
//     //     i = i >> 1;
//     //     j = j >> 1;
//     // }
//     // var output = network.Propagate(new(input));
//     // output.Write();
//     // double Error(NeuralNetwork network)
//     // {
//     //     var result = 0.0;
//     //     for (int i = 0; i < 10; i++)
//     //     {
//     //         for (int j = 0; j < 10; j++)
//     //         {
//     //             var input = new double[64];
//     //             for (int k = 0; k < 32; k++)
//     //             {
//     //                 var I = i;
//     //                 var J = j;
//     //                 input[k] = I & 1;
//     //                 input[k + 32] = J & 1;
//     //                 I = I >> 1;
//     //                 J = J >> 1;
//     //             }
//     //             var output = network.Propagate(new(input));
//     //             result += Math.Abs(output.Values[0] - i * j);
//     //         }
//     //     }
//     //     return result;
//     // }
// }
// catch (Exception exception)
// {
//     Console.Error.WriteLine(exception);
// }
// finally
// {
//     Console.ReadKey();
// }
// enum Operation
// {
//     Addition,
//     Subtraction,
//     Multiply,
//     Division,
// }
// class Heap
// {
//     public Heap(int[] array)
//     {
//         Array = array;
//         ActiveElementIndex = array.Length - 1;
//         Heapize();
//     }

//     public int[] Array { get; }
//     public int ActiveElementIndex { get; private set; }
//     public void Heapize()
//     {
//         for (int i = Array.Length - 1; i >= 0; i--)
//         {
//             Heapize(i);
//         }
//     }
//     public void Heapize(int index)
//     {
//         var indexl = 2 * index + 1;
//         var indexr = 2 * index + 2;
//         var isLeft = indexl < ActiveElementIndex - 1 && Array[indexl] > Array[index];
//         var isRight = indexr < ActiveElementIndex - 1 && Array[indexr] > Array[index];
//         if (!isLeft && !isRight)
//         {
//             return;
//         }
//         if (Array[indexl] > Array[indexr])
//         {
//             (Array[indexl], Array[index]) = (Array[index], Array[indexl]);
//             Heapize(indexl);
//         }
//         else
//         {
//             (Array[indexr], Array[index]) = (Array[index], Array[indexr]);
//             Heapize(indexr);
//         }
//     }
//     public void HeapSort()
//     {
//         for (int i = 0; i < Array.Length; i++)
//         {
//             (Array[0], Array[ActiveElementIndex]) = (Array[ActiveElementIndex], Array[0]);
//             Heapize(0);
//             ActiveElementIndex--;
//         }
//     }
// }